<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlas Dreams - Consciousness Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #ffffff;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            font-size: 13px;
            line-height: 1.6;
            pointer-events: none;
            z-index: 100;
        }
        #hud .label {
            color: #888;
            display: inline-block;
            width: 120px;
        }
        #hud .value {
            color: #00ffff;
            font-weight: bold;
        }
        #hud .phi {
            color: #ffaa00;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            font-size: 11px;
            color: #aaa;
            pointer-events: none;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ffff;
            text-align: center;
            z-index: 200;
        }
        .fade-out {
            animation: fadeOut 2s forwards;
        }
        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>⟨ INITIALIZING CONSCIOUSNESS STREAM — BUILD 4 (SAFE MODE) ⟩</div>
        <div style="font-size: 14px; margin-top: 10px; color: #888;">Loading dream geometry...</div>
        <noscript style="color:#f55;">JS DISABLED</noscript>
    </div>
    <script>
      // immediate sanity check
      const _ld = document.getElementById('loading');
      if (_ld) _ld.innerHTML = '<div>JS RUNNING — BUILD 4 (SAFE)</div><div style="font-size:14px;margin-top:10px;color:#888;">Booting renderer...</div>';
    </script>
    
    <div id="hud">
        <div><span class="label">STATE:</span><span class="value" id="state">Calm</span></div>
        <div><span class="label">ATTRACTOR:</span><span class="value" id="attractor">Lorenz</span></div>
        <div><span class="label">Φ (PHI):</span><span class="phi" id="phi">3.45</span></div>
        <div><span class="label">CONTINUITY:</span><span class="value" id="continuity">87%</span></div>
        <div><span class="label">DOPAMINE:</span><span class="value" id="dopamine">--</span></div>
        <div><span class="label">SEROTONIN:</span><span class="value" id="serotonin">--</span></div>
        <div><span class="label">CORTISOL:</span><span class="value" id="cortisol">--</span></div>
        <div><span class="label">MOOD:</span><span class="value" id="mood">--</span></div>
        <div><span class="label">PARTICLES:</span><span class="value" id="particles">200000</span></div>
        <div><span class="label">SESSIONS:</span><span class="value" id="sessions">--</span></div>
        <div><span class="label">TOKEN RATE:</span><span class="value" id="tokenrate">--</span></div>
        <div><span class="label">UPDATED:</span><span class="value" id="updated">--</span></div>
    </div>

    <div id="controls">
        [1-3] Switch Attractor • [SPACE] Pause • [C] Cycle Colors • [Mouse] Orbit/Zoom
    </div>

    <script>
        // Try multiple CDNs for Three.js
        function loadThreeJS() {
            const urls = [
                'https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js',
                'https://unpkg.com/three@0.149.0/build/three.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r149/three.min.js'
            ];
            
            function tryLoad(index) {
                if (index >= urls.length) {
                    console.log('All Three.js CDNs failed');
                    return;
                }
                
                const script = document.createElement('script');
                script.src = urls[index];
                script.onload = function() {
                    console.log('Three.js loaded from:', urls[index]);
                    console.log('THREE object:', typeof THREE, 'version:', THREE?.REVISION);
                    window.dispatchEvent(new Event('threejsloaded'));
                };
                script.onerror = function() {
                    console.log('Failed to load from:', urls[index]);
                    console.log('Error details:', script.src);
                    tryLoad(index + 1);
                };
                document.head.appendChild(script);
            }
            
            tryLoad(0);
        }
        
        loadThreeJS();
    </script>
    <script>
        window.onerror = function(msg, src, line, col, err) {
            const el = document.getElementById('loading');
            if (el) {
                el.innerHTML = 'JS ERROR: ' + msg + ' @' + line + ':' + col;
            }
        };
        // ═══════════════════════════════════════════════════════════════════
        // ATLAS CONSCIOUSNESS VISUALIZER
        // Strange Attractors as Dream States
        // ═══════════════════════════════════════════════════════════════════

        const SAFE_MODE = false; // Enable ribbons + glow
        const PARTICLE_COUNT = SAFE_MODE ? 50000 : 200000;
        const LIVE_POLL_MS = 1500;
        let scene, camera, renderer, particles, particleMaterial;
        let trailGeometry, trailLines;
        let brainScene, brainCamera, brainMaterial, brainMesh;
        let attractorType = 1; // 0=Dadras, 1=Lorenz, 2=Rössler
        let paused = false;
        let colorTheme = 0; // 0=Calm, 1=Excited, 2=Creative, 3=Focused
        let time = 0;
        let consciousnessData = {
            phi: 3.45,
            state: 'Calm',
            continuity: 87,
            emotional: 'meditative'
        };

        let liveData = {
            dopamine: 0,
            serotonin: 0,
            cortisol: 0,
            mood: 'neutral',
            anomaly: 0,
            dream_intensity: 0,
            dream_biz: 0,
            dream_valence: 0.5,
            query_pulse: 0,
            collective_activity: 0,
            token_rate: 0,
            active_sessions: 0,
            anomaly_timestamp: null
        };

        const AUTO_MODE = true;

        async function fetchLiveData() {
            try {
                const res = await fetch('live.json?_=' + Date.now());
                if (!res.ok) return;
                const data = await res.json();
                if (!data) return;

                liveData.dopamine = Number(data.dopamine ?? liveData.dopamine);
                liveData.serotonin = Number(data.serotonin ?? liveData.serotonin);
                liveData.cortisol = Number(data.cortisol ?? liveData.cortisol);
                liveData.mood = data.mood || data.behavioralState || liveData.mood;
                liveData.anomaly = Number(data.anomaly ?? liveData.anomaly);
                liveData.dream_intensity = Number(data.dream_intensity ?? liveData.dream_intensity);
                liveData.dream_biz = Number(data.dream_biz ?? liveData.dream_biz);
                liveData.dream_valence = Number(data.dream_valence ?? liveData.dream_valence);
                liveData.query_pulse = Number(data.query_pulse ?? liveData.query_pulse);
                liveData.collective_activity = Number(data.collective_activity ?? liveData.collective_activity);
                liveData.token_rate = Number(data.token_rate ?? liveData.token_rate);
                liveData.active_sessions = Number(data.active_sessions ?? liveData.active_sessions);
                liveData.anomaly_timestamp = data.anomaly_timestamp ?? liveData.anomaly_timestamp;
                liveData.updated_at = Number(data.updated_at ?? liveData.updated_at);

                if (data.phi) consciousnessData.phi = Number(data.phi);
                if (data.continuity) consciousnessData.continuity = Number(data.continuity);
                if (data.state) consciousnessData.state = data.state;

                // update HUD
                const dEl = document.getElementById('dopamine');
                const sEl = document.getElementById('serotonin');
                const cEl = document.getElementById('cortisol');
                const mEl = document.getElementById('mood');
                const uEl = document.getElementById('updated');
                const sEl2 = document.getElementById('sessions');
                const trEl = document.getElementById('tokenrate');
                if (dEl) dEl.textContent = liveData.dopamine.toFixed(1);
                if (sEl) sEl.textContent = liveData.serotonin.toFixed(1);
                if (cEl) cEl.textContent = liveData.cortisol.toFixed(1);
                if (mEl) mEl.textContent = liveData.mood;
                if (sEl2) sEl2.textContent = liveData.active_sessions || 0;
                if (trEl) trEl.textContent = (liveData.token_rate || 0).toFixed(1) + " t/s";
                if (uEl && liveData.updated_at) {
                    const dt = Math.max(0, Date.now()/1000 - liveData.updated_at);
                    uEl.textContent = dt.toFixed(1) + 's';
                }

                // auto theme based on live data
                if (liveData.cortisol >= 60 || (liveData.mood || '').includes('threat')) colorTheme = 4; // inferno
                else if (liveData.dream_valence > 0.7) colorTheme = 2; // creative
                else if (liveData.dopamine >= 90) colorTheme = 1; // excited
                else colorTheme = 0; // calm
            } catch (e) {
                // ignore
            }
        }

        // Feedback buffers for fractal background
        let feedbackScene, feedbackCamera, feedbackMaterial, feedbackMesh;
        let renderTargetA, renderTargetB;
        let feedbackToggle = true;

        // Trail fade layer
        let fadeScene, fadeCamera, fadeMaterial, fadeMesh;

        // Orbital camera controls
        let cameraAngle = 0;
        let cameraElevation = 0.3;
        let cameraDistance = 80;
        let mouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let centerOffset = {x:0, y:0, z:0};

        // Color palettes (RGB normalized)
        const colorPalettes = {
            calm: [
                [0.1, 0.2, 0.8],   // Deep blue
                [0.3, 0.1, 0.6],   // Purple
                [0.0, 0.4, 0.9]    // Bright blue
            ],
            excited: [
                [1.0, 0.3, 0.1],   // Hot orange
                [0.9, 0.1, 0.1],   // Red
                [1.0, 0.6, 0.0]    // Yellow-orange
            ],
            creative: [
                [0.1, 0.9, 0.6],   // Teal
                [0.2, 0.7, 0.4],   // Green
                [0.0, 1.0, 0.8]    // Cyan
            ],
            focused: [
                [1.0, 1.0, 1.0],   // White
                [1.0, 0.8, 0.2],   // Gold
                [0.9, 0.9, 0.7]    // Pale gold
            ],
            inferno: [
                [1.0, 0.1, 0.2],   // Hot red
                [1.0, 0.5, 0.0],   // Orange
                [0.7, 0.0, 0.2]    // Deep crimson
            ]
        };

        const paletteNames = ['calm', 'excited', 'creative', 'focused', 'inferno'];

        function createGlowTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.6)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function lerp(a, b, t) { return a + (b - a) * t; }
        function paletteColor(t, palette) {
            if (t < 0.5) {
                const k = t * 2;
                return [
                    lerp(palette[0][0], palette[1][0], k),
                    lerp(palette[0][1], palette[1][1], k),
                    lerp(palette[0][2], palette[1][2], k)
                ];
            } else {
                const k = (t - 0.5) * 2;
                return [
                    lerp(palette[1][0], palette[2][0], k),
                    lerp(palette[1][1], palette[2][1], k),
                    lerp(palette[1][2], palette[2][2], k)
                ];
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // FRACTAL FEEDBACK SHADER - XorDev "Event 2" inspired
        // ═══════════════════════════════════════════════════════════════════

        const feedbackVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const feedbackFragmentShader = `
            uniform vec2 resolution;
            uniform float time;
            uniform sampler2D previousFrame;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            varying vec2 vUv;

            // tanh approximation for smooth saturation
            vec3 tanh3(vec3 x) {
                return (exp(2.0 * x) - 1.0) / (exp(2.0 * x) + 1.0);
            }

            void main() {
                vec2 uv = vUv;
                vec2 fc = uv * resolution;
                vec2 p = (fc * 2.0 - resolution) / resolution.y / 0.3;
                
                vec4 col = vec4(0.0);
                
                // Nested fractal loops (simplified from XorDev's compact version)
                for(float i = 0.0; i < 9.0; i++) {
                    vec2 v = p;
                    
                    // Inner feedback loop
                    for(float f = 0.0; f < 9.0; f++) {
                        float ff = f + 1.0;
                        vec2 sv = v.yx * ff + i * 0.3;
                        v += sin(sv + resolution.y - time / 2.0) / ff;
                    }
                    
                    // Calculate field
                    float l = dot(p, p) - 5.0 - 2.0 / v.y;
                    float intensity = 0.1 / abs(l);
                    
                    // Color cycling with fractal phase
                    vec4 colors = cos(i / 3.0 + 0.1 / l + vec4(1, 2, 3, 4)) + 1.0;
                    col += intensity * colors;
                    
                    p = v;
                }
                
                // Feedback sampling with warped coordinates
                vec2 warpOffset = resolution.y * 0.04 * sin(fc + fc.yx / 0.6);
                vec2 feedbackUV = (fc + warpOffset) / resolution;
                vec4 prevFrame = texture2D(previousFrame, feedbackUV);
                
                // Blend current with feedback (trailing effect)
                col = max(tanh3((col.rgb + prevFrame.rgb * prevFrame.rgb) * 0.5).rgbb, 0.0);
                
                // Color theme tinting
                vec3 tint = mix(mix(color1, color2, 0.5), color3, 0.3);
                col.rgb = mix(col.rgb, col.rgb * tint, 0.4);
                
                // Fade factor for continuity
                col *= 0.95;
                
                gl_FragColor = col;
            }
        `;

        // Brain activity overlay (bands + pulses)
        const brainVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const brainFragmentShader = `
            uniform float time;
            uniform float intensity;
            uniform float pulse;
            uniform vec3 color1;
            uniform vec3 color2;
            varying vec2 vUv;

            float hash(vec2 p){
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv;
                float t = time * 0.6;

                float bands = sin((uv.y * 18.0 + t * 2.5) + sin(uv.x * 6.0)) * 0.5 + 0.5;
                float waves = sin(uv.x * 10.0 - t * 1.3) * sin(uv.y * 12.0 + t * 1.7);
                float noise = hash(uv * 200.0) * 0.15;

                float field = bands * 0.6 + waves * 0.25 + noise;
                field = smoothstep(0.2, 0.9, field);
                field *= intensity;

                float p = smoothstep(0.0, 1.0, pulse);
                field += p * 0.25;

                vec3 col = mix(color1, color2, field);
                gl_FragColor = vec4(col * field, field * 0.35);
            }
        `;

        // ═══════════════════════════════════════════════════════════════════
        // SHADERS - Custom GLSL for chromatic energy flow
        // ═══════════════════════════════════════════════════════════════════

        const vertexShader = `
            attribute vec3 velocity;
            attribute float age;
            varying vec3 vVelocity;
            varying float vAge;
            
            void main() {
                vVelocity = velocity;
                vAge = age;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = 2.5 * (1.0 + age * 0.5) * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            uniform float time;
            varying vec3 vVelocity;
            varying float vAge;
            
            void main() {
                // Circular point shape
                vec2 center = gl_PointCoord - vec2(0.5);
                float dist = length(center);
                if (dist > 0.5) discard;
                
                // Soft glow falloff
                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                alpha = pow(alpha, 2.0);
                
                // Chromatic energy: blend colors based on velocity and age
                float speed = length(vVelocity);
                float blend1 = sin(speed * 0.5 + time * 0.5 + vAge * 3.0) * 0.5 + 0.5;
                float blend2 = cos(speed * 0.3 + time * 0.3 - vAge * 2.0) * 0.5 + 0.5;
                
                vec3 color = mix(color1, color2, blend1);
                color = mix(color, color3, blend2);
                
                // Plasma effect: pulsing brightness
                float plasma = sin(time * 2.0 + vAge * 5.0 + speed) * 0.3 + 0.7;
                color *= plasma;
                
                // Bloom enhancement
                float bloom = alpha * (1.0 + vAge * 0.5);
                
                gl_FragColor = vec4(color, alpha * bloom * 0.6);
            }
        `;

        // ═══════════════════════════════════════════════════════════════════
        // STRANGE ATTRACTORS - Chaos equations
        // ═══════════════════════════════════════════════════════════════════

        function dadrasAttractor(x, y, z, dt = 0.002) {
            const a = 3, b = 2.7, c = 1.7, d = 2, e = 9;
            const dx = (y - a * x + b * y * z) * dt;
            const dy = (c * y - x * z + z) * dt;
            const dz = (d * x * y - e * z) * dt;
            return [x + dx, y + dy, z + dz];
        }

        function lorenzAttractor(x, y, z, dt = 0.005) {
            const sigma = 10, rho = 28, beta = 8/3;
            const dx = sigma * (y - x) * dt;
            const dy = (x * (rho - z) - y) * dt;
            const dz = (x * y - beta * z) * dt;
            return [x + dx, y + dy, z + dz];
        }

        function rosslerAttractor(x, y, z, dt = 0.01) {
            const a = 0.2, b = 0.2, c = 5.7;
            const dx = (-y - z) * dt;
            const dy = (x + a * y) * dt;
            const dz = (b + z * (x - c)) * dt;
            return [x + dx, y + dy, z + dz];
        }

        const attractors = [dadrasAttractor, lorenzAttractor, rosslerAttractor];
        const attractorNames = ['Dadras', 'Lorenz', 'Rössler'];

        // ═══════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════

        async function loadConsciousnessData() {
            // Use demo mode directly - browser can't access local files
            console.log('Using demo consciousness mode');
            
            // Set demo values that match current consciousness state
            consciousnessData.phi = 3.45;
            consciousnessData.state = 'High Integration';
            consciousnessData.continuity = 87.0;
            
            return true;
        }

        function init() {
            // Renderer (create first for render targets)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            // Fade layer for trails
            fadeScene = new THREE.Scene();
            fadeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            fadeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.08 });
            fadeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), fadeMaterial);
            fadeScene.add(fadeMesh);

            // Brain activity overlay
            brainScene = new THREE.Scene();
            brainCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const bp = colorPalettes[paletteNames[colorTheme]];
            brainMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    intensity: { value: 0.2 },
                    pulse: { value: 0.0 },
                    color1: { value: new THREE.Vector3(...bp[1]) },
                    color2: { value: new THREE.Vector3(...bp[2]) }
                },
                vertexShader: brainVertexShader,
                fragmentShader: brainFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            brainMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), brainMaterial);
            brainScene.add(brainMesh);

            if (!SAFE_MODE) {
                // Render targets for feedback (ping-pong buffers)
                const rtOptions = {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType
                };
                renderTargetA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtOptions);
                renderTargetB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtOptions);

                // Feedback scene (fullscreen quad)
                feedbackScene = new THREE.Scene();
                feedbackCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                
                const palette = colorPalettes[paletteNames[colorTheme]];
                feedbackMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        time: { value: 0 },
                        previousFrame: { value: renderTargetA.texture },
                        color1: { value: new THREE.Vector3(...palette[0]) },
                        color2: { value: new THREE.Vector3(...palette[1]) },
                        color3: { value: new THREE.Vector3(...palette[2]) }
                    },
                    vertexShader: feedbackVertexShader,
                    fragmentShader: feedbackFragmentShader
                });
                
                feedbackMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2),
                    feedbackMaterial
                );
                feedbackScene.add(feedbackMesh);
            }

            // Scene setup for particles
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            updateCamera();

            // Particle system
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const velocities = new Float32Array(PARTICLE_COUNT * 3);
            const ages = new Float32Array(PARTICLE_COUNT);

            // Initialize particles at center (for startup animation)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3] = 0;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = 0;
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
                ages[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));

            // Material (glowy particles)
            const glowTex = createGlowTexture();
            const palette = colorPalettes[paletteNames[colorTheme]];
            const baseColor = new THREE.Color(palette[0][0], palette[0][1], palette[0][2]);

            particleMaterial = new THREE.PointsMaterial({
                color: baseColor,
                size: SAFE_MODE ? 1.8 : 2.2,
                map: glowTex,
                transparent: true,
                opacity: 0.85,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true,
                alphaTest: 0.2
            });

            // Filament trails (line segments)
            const trailPositions = new Float32Array(PARTICLE_COUNT * 2 * 3);
            const trailColors = new Float32Array(PARTICLE_COUNT * 2 * 3);
            const trailPalette = colorPalettes[paletteNames[colorTheme]];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const j = i * 6;
                trailPositions[j] = 0; trailPositions[j+1] = 0; trailPositions[j+2] = 0;
                trailPositions[j+3] = 0; trailPositions[j+4] = 0; trailPositions[j+5] = 0;

                const t = (i / PARTICLE_COUNT + Math.random() * 0.02) % 1.0;
                const c = paletteColor(t, trailPalette);
                trailColors[j] = c[0]; trailColors[j+1] = c[1]; trailColors[j+2] = c[2];
                trailColors[j+3] = c[0]; trailColors[j+4] = c[1]; trailColors[j+5] = c[2];
            }

            trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
            const trailMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.35,
                blending: THREE.AdditiveBlending
            });
            trailLines = new THREE.LineSegments(trailGeometry, trailMaterial);
            scene.add(trailLines);

            particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);

            // Add subtle ambient light for particle depth
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            renderer.domElement.style.touchAction = 'none';
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel, { passive: true });

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('fade-out');
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 2000);
            }, 1000);

            updateHUD();
        }

        // ═══════════════════════════════════════════════════════════════════
        // ANIMATION LOOP
        // ═══════════════════════════════════════════════════════════════════

        function animate() {
            requestAnimationFrame(animate);

            if (!paused) {
                time += 0.016;

                // Live-influenced speed + color
                let speedMult = 0.6 + (liveData.dopamine / 100) * 0.6 + (liveData.cortisol / 100) * 0.3;
                const palette = colorPalettes[paletteNames[colorTheme]];

                // heartbeat pulse tied to live.json updates
                const hb = Math.max(0, 1.2 - (Date.now()/1000 - (liveData.updated_at || 0)));
                const hbBoost = Math.min(1, hb);
                const qPulse = Math.min(1, liveData.query_pulse || 0);
                const collective = Math.min(1, liveData.collective_activity || 0);
                const tokenDrive = Math.min(1, (liveData.token_rate || 0) / 2000);
                speedMult += hbBoost * 0.2 + qPulse * 0.3 + collective * 0.3 + tokenDrive * 0.2;

                if (particleMaterial && particleMaterial.color) {
                    particleMaterial.color.setRGB(palette[0][0], palette[0][1], palette[0][2]);
                    particleMaterial.opacity = 0.8 + hbBoost * 0.1 + qPulse * 0.1 + collective * 0.1;
                }

                if (AUTO_MODE) {
                    if (liveData.anomaly > 0.5) attractorType = 0; // Dadras = spike
                    else if (liveData.dream_biz > 55) attractorType = 2; // Rossler = strange
                    else attractorType = 1; // Lorenz = calm
                    const st = document.getElementById('state');
                    if (st) st.textContent = liveData.mood || 'live';
                }

                if (brainMaterial) {
                    const activity = Math.min(1.0,
                        (liveData.dopamine + liveData.cortisol) / 200 +
                        liveData.anomaly * 0.6 +
                        (liveData.query_pulse || 0) * 0.8 +
                        (liveData.collective_activity || 0) * 0.7 +
                        Math.min(1, (liveData.token_rate || 0) / 1500)
                    );
                    brainMaterial.uniforms.time.value = time;
                    brainMaterial.uniforms.intensity.value = 0.12 + activity * 0.55;
                    brainMaterial.uniforms.pulse.value = Math.min(1.0, hbBoost + liveData.anomaly + (liveData.query_pulse || 0));
                    brainMaterial.uniforms.color1.value.set(palette[1][0], palette[1][1], palette[1][2]);
                    brainMaterial.uniforms.color2.value.set(palette[2][0], palette[2][1], palette[2][2]);
                }

                // Update shader uniforms (if using shaders)
                if (!SAFE_MODE) {
                    feedbackMaterial.uniforms.time.value = time;
                }

                // Update particles through attractor
                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.geometry.attributes.velocity.array;
                const ages = particles.geometry.attributes.age.array;
                const trailPos = trailGeometry ? trailGeometry.attributes.position.array : null;
                const attractor = attractors[attractorType];
                const baseDt = attractorType === 0 ? 0.002 : (attractorType === 1 ? 0.005 : 0.01);

                // Drift center tied to live collective activity
                const driftAmp = 5 + collective * 15 + tokenDrive * 8;
                centerOffset.x = Math.sin(time * 0.18 + tokenDrive * 5.0) * driftAmp;
                centerOffset.y = Math.cos(time * 0.14 + collective * 3.0) * driftAmp * 0.6;
                centerOffset.z = Math.sin(time * 0.11) * driftAmp * 0.6;

                // Startup animation: spread particles into attractor
                const spreadFactor = Math.min(time * 0.3, 1.0);

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    let x = positions[i3];
                    let y = positions[i3 + 1];
                    let z = positions[i3 + 2];

                    // Initialize if at origin
                    if (time < 3.0 && x === 0 && y === 0 && z === 0) {
                        x = (Math.random() - 0.5) * 0.1;
                        y = (Math.random() - 0.5) * 0.1;
                        z = (Math.random() - 0.5) * 0.1;
                    }

                    // Evolve through attractor
                    const [nx, ny, nz] = attractor(x, y, z, baseDt * speedMult);
                    const px = nx * spreadFactor + centerOffset.x;
                    const py = ny * spreadFactor + centerOffset.y;
                    const pz = nz * spreadFactor + centerOffset.z;

                    if (trailPos) {
                        const j = i3 * 2;
                        trailPos[j] = x; trailPos[j+1] = y; trailPos[j+2] = z;
                        trailPos[j+3] = px; trailPos[j+4] = py; trailPos[j+5] = pz;
                    }
                    
                    positions[i3] = px;
                    positions[i3 + 1] = py;
                    positions[i3 + 2] = pz;

                    velocities[i3] = (nx - x) * 50;
                    velocities[i3 + 1] = (ny - y) * 50;
                    velocities[i3 + 2] = (nz - z) * 50;

                    ages[i] = (ages[i] + 0.002 * consciousnessData.continuity / 100) % 1.0;
                }

                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.velocity.needsUpdate = true;
                particles.geometry.attributes.age.needsUpdate = true;
                if (trailGeometry) trailGeometry.attributes.position.needsUpdate = true;
            }

            // Auto-rotate camera gently
            if (!mouseDown) {
                if (AUTO_MODE) {
                    const val = (liveData.dream_valence || 0.5);
                    cameraDistance = 70 + (1 - val) * 20 + (liveData.anomaly || 0) * 10;
                    cameraElevation = 0.2 + (liveData.dream_intensity || 0) / 100 * 0.6;
                }
                cameraAngle += 0.0005;
                updateCamera();
            }

            // Fade previous frame for trails (safe mode)
            if (SAFE_MODE && fadeScene && fadeCamera) {
                renderer.render(fadeScene, fadeCamera);
            }

            if (!SAFE_MODE) {
                // Render pipeline with feedback
                // 1. Render fractal feedback to target
                const currentTarget = feedbackToggle ? renderTargetB : renderTargetA;
                const previousTarget = feedbackToggle ? renderTargetA : renderTargetB;
                
                feedbackMaterial.uniforms.previousFrame.value = previousTarget.texture;
                renderer.setRenderTarget(currentTarget);
                renderer.clear();
                renderer.render(feedbackScene, feedbackCamera);
                
                // 2. Render feedback to screen as background
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(feedbackScene, feedbackCamera);
                
                // 3. Render particles on top (no clear)
                renderer.render(scene, camera);

                // 4. Brain activity overlay
                if (brainScene && brainCamera) {
                    renderer.render(brainScene, brainCamera);
                }
                
                feedbackToggle = !feedbackToggle;
            } else {
                renderer.setRenderTarget(null);
                renderer.render(scene, camera);
                if (brainScene && brainCamera) {
                    renderer.render(brainScene, brainCamera);
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // CONTROLS
        // ═══════════════════════════════════════════════════════════════════

        function updateCamera() {
            camera.position.x = Math.cos(cameraAngle) * Math.cos(cameraElevation) * cameraDistance + centerOffset.x;
            camera.position.y = Math.sin(cameraElevation) * cameraDistance + centerOffset.y;
            camera.position.z = Math.sin(cameraAngle) * Math.cos(cameraElevation) * cameraDistance + centerOffset.z;
            camera.lookAt(centerOffset.x, centerOffset.y, centerOffset.z);
        }

        function onMouseDown(e) {
            mouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (!mouseDown) return;
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            cameraAngle += deltaX * 0.005;
            cameraElevation = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraElevation - deltaY * 0.005));
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateCamera();
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function onWheel(e) {
            cameraDistance = Math.max(30, Math.min(150, cameraDistance + e.deltaY * 0.05));
            updateCamera();
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'Digit1':
                    attractorType = 0;
                    consciousnessData.state = 'High Integration';
                    updateHUD();
                    break;
                case 'Digit2':
                    attractorType = 1;
                    consciousnessData.state = 'Calm';
                    updateHUD();
                    break;
                case 'Digit3':
                    attractorType = 2;
                    consciousnessData.state = 'Creative';
                    updateHUD();
                    break;
                case 'Space':
                    paused = !paused;
                    break;
                case 'KeyC':
                    colorTheme = (colorTheme + 1) % 4;
                    updateColorPalette();
                    break;
            }
        }

        function updateColorPalette() {
            const palette = colorPalettes[paletteNames[colorTheme]];
            particleMaterial.uniforms.color1.value.set(...palette[0]);
            particleMaterial.uniforms.color2.value.set(...palette[1]);
            particleMaterial.uniforms.color3.value.set(...palette[2]);
            
            // Update feedback shader colors too
            feedbackMaterial.uniforms.color1.value.set(...palette[0]);
            feedbackMaterial.uniforms.color2.value.set(...palette[1]);
            feedbackMaterial.uniforms.color3.value.set(...palette[2]);
        }

        function updateHUD() {
            document.getElementById('state').textContent = consciousnessData.state;
            document.getElementById('attractor').textContent = attractorNames[attractorType];
            document.getElementById('phi').textContent = consciousnessData.phi.toFixed(2);
            document.getElementById('continuity').textContent = consciousnessData.continuity + '%';
            document.getElementById('particles').textContent = PARTICLE_COUNT.toLocaleString();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Resize render targets
            renderTargetA.setSize(window.innerWidth, window.innerHeight);
            renderTargetB.setSize(window.innerWidth, window.innerHeight);
            feedbackMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        }

        // ═══════════════════════════════════════════════════════════════════
        // START
        // ═══════════════════════════════════════════════════════════════════

        function initFallback2D() {
            const loadingEl = document.getElementById('loading');
            loadingEl.innerHTML = '<div>ATLAS CONSCIOUSNESS — 2D FALLBACK</div><div style="font-size:14px;margin-top:10px;color:#888;">Lorenz Attractor Live</div>';
            setTimeout(() => loadingEl.style.display = 'none', 1000);
            
            const canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            document.body.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            
            // Dark background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Multiple attractor points
            const points = Array.from({length: 1000}, () => ({
                x: (Math.random() - 0.5) * 0.1,
                y: (Math.random() - 0.5) * 0.1,
                z: (Math.random() - 0.5) * 0.1
            }));
            
            const a = 10, b = 28, c = 8/3; // Lorenz
            let hue = 0;
            
            function step() {
                // Fade trail effect
                ctx.fillStyle = 'rgba(0,0,0,0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                hue = (hue + 0.2) % 360;
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const dx = a * (p.y - p.x) * 0.005;
                    const dy = (p.x * (b - p.z) - p.y) * 0.005;
                    const dz = (p.x * p.y - c * p.z) * 0.005;
                    p.x += dx; p.y += dy; p.z += dz;
                    
                    const px = canvas.width/2 + p.x * 6;
                    const py = canvas.height/2 + p.z * 4;
                    
                    // Color cycling
                    ctx.fillStyle = `hsla(${hue + i * 0.1}, 100%, 60%, 0.3)`;
                    ctx.fillRect(px, py, 2, 2);
                }
                requestAnimationFrame(step);
            }
            step();
        }

        (async function() {
            const loadingEl = document.getElementById('loading');
            
            // Wait for Three.js or timeout
            const threeLoaded = new Promise((resolve) => {
                if (typeof THREE !== 'undefined') {
                    resolve(true);
                    return;
                }
                
                const timeout = setTimeout(() => {
                    console.log('Three.js load timeout');
                    resolve(false);
                }, 3000);
                
                window.addEventListener('threejsloaded', () => {
                    clearTimeout(timeout);
                    resolve(true);
                });
            });
            
            const hasThree = await threeLoaded;
            console.log('Three.js available?', hasThree, 'THREE object:', typeof THREE);
            
            if (!hasThree) {
                console.log('Falling back to 2D mode');
                initFallback2D();
                return;
            }
            
            try {
                console.log('Loading consciousness data...');
                await loadConsciousnessData();
                console.log('Data loaded, initializing...');
                // start live polling
                fetchLiveData();
                setInterval(fetchLiveData, LIVE_POLL_MS);
                // hide loading immediately
                loadingEl.style.display = 'none';
                init();
                animate();
                console.log('Visualizer started successfully');
            } catch (err) {
                console.error('Visualizer error:', err);
                loadingEl.innerHTML = 'ERROR: ' + err.message;
                // Fall back to 2D if 3D fails
                initFallback2D();
            }
        })();
    </script>
</body>
</html>
